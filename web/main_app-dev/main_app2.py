from flask import Flask, render_template, request, session, url_for#, session
from flask_bootstrap import Bootstrap
from flask_debugtoolbar import DebugToolbarExtension
from make_form1 import make_form1

import RuleSet
import r_funcs
from projection_funcs import variablise, slicify

import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import pprint as pprint
from datetime import datetime
import pickle
import os

app = Flask(__name__)
bootstrap = Bootstrap(app)
app.config['SECRET_KEY'] = 'vq98ervhq98743yh'
app.debug=True
# toolbar = DebugToolbarExtension(app)

# df = pd.read_pickle('c:/Users/groberta/Work/data_accelerator/spend_data_proc/dfs/main_unstacked_17AUG.pkl') # old df
df = pd.read_pickle('c:/Users/groberta/Work/data_accelerator/spend_data_proc/dfs/main_df_new_dates_13SEP2017a.pkl')
cutoff = pd.Period('3-2014', freq='M')
npers = 120

plt.style.use('seaborn')

pad1 = 30

phx_adj = 1.65 # pharmex omits a bunch of spend - this is the ave adjustment reqd

rulesets = {}
# rulesets['rs1'] = RuleSet.RuleSet(df, 'rs1')
func_table={'r_profile':r_funcs.r_profile, 
        'r_tprofile':r_funcs.r_tprofile, 
        'r_terminal':r_funcs.r_terminal, 
        'r_trend':r_funcs.r_trend, 
        'r_fut':r_funcs.r_fut, 
        'r_fut_tr':r_funcs.r_fut_tr}
        # NB currently need to hard code these options in make_form1(), to get in the SelectField

outfigs={} 



@app.route('/', methods=['GET', 'POST'])
def home():

    '''OVERVIEW

    The initial invocation of `make_form()` generates a form based on the common *structure* of the request.POST 
    object form, and the rulesets dictionary.

    The request form is a superset of the ruleset dict, with metafields such as `add_ruleset`, plus the structures of all
    the actual rulesets (which correspond with the ruleset dict).

    The overlap (i.e. the element of the request.form corresponding to the rulesets dictionary) can differ
    in two ways between the two objects.  These differences determine how the form and rulesets dict are processed.

       Field data (form ahead of rulesets dict, so update ruleset dict).  
           - the request.form may have additional info from user, eg updated coefficients for fields   
           - these fields are already consistent in the common structure
           - so all that needs to happen is for the rulesets dict to be updated with the new values
           - the form generated by the initial `make_form()` will automatically be populated with this data

       Structural information (form has info for changing ruleset dict, but then form structure must update)
           - the request.form may have info requiring changes to the structure of rulesets dict (and hence the form)
               - eg add, load or delete rulesets
               - eg selection of aa new r_func for a ruleset
           - this requires more processing than just updating fields:
               - make the changes to the ruleset dict, eg make a new instance, or delete an instance
               - generate a new form, based on the updated structure
               - [ensure new form is populated with data - don't think this is currently relevant but may be in future]  

    So the process required is:

        1. Initial call to `make_form()`
            - generates form based on common structure, with user updates to fields plus structural/meta info
            - form has same structure as ruleset (for common elements, i.e. rulesets)
            - form may have different field data (incl r_funcs)
            - form may have meta instructions for changing structure (load, delete, new, plot)
            - form may have process instructions (save)

        2. Delete any rulesets marked for deletion
            - (or clear_all)
            - form and rulesets dict differ by deleted ruleset

        3. Of remaining rulesets, update data according to form fields (NB including r_func field)
            - form and rulesets dict now have consistent data where structure overlaps
            - still differ by deleted ruleset
            [currently do some pre processing in the form - variablise() and slicify() - before updating rulesets]
        
        4. Create or load any new rulesets
            - form and rulesets dict differ by these additional rulesets, plus their field data
    
        5. Call `make_form()` again, to make a new form based on the new ruleset dict structure
            - including new r_func, and new rulesets (or deleted rulesets)   

        [PLOT - this will change the rulesets, but the results don't have to come back to the form.. ..YET]
        [ insert between 2nd make_form and update form data, to enable this]
        [ iterate thru ruleset dict, calling xtrap()]

        6. Update form data
            - needs to reflect field data in loaded datasets (defaults in new?)
            - turn off any flags? (or could do after their executed)

        7. Render form to page

        CODE DOES NOT CURRENTLY FOLLOW THIS ORDER - for plotting only, I think

    '''

    active_rset = None

    print("\n***************************CALLING APP *****************************")

    print('\nINITIAL RULESETS')
    pprint.pprint(rulesets)
    
    # 1. Initial call to `make_form()`
    form = make_form1(rulesets)

    print('\nFORM AFTER INITIAL MAKE_FORM')
    pprint.pprint(form.data)


    if form.submit(): # I think it always is
        print('\nSubmission detected')
        active_rset = session.get('last_active_rset', None)
        print('active rset'.ljust(pad1), active_rset)
        # check for clear all
        if form.clear_all.data:
            print("3. Clearing all rulesets")
            rulesets.clear()
            outfigs.clear()
            active_rset = None
            print("rulesets after clear_all:".ljust(pad1), [n for n in rulesets])

        # iterate through the rulesets, deleting and updating
        print("\nPARSING FORM AND UPDATING RULESET")
        for r in rulesets:

            print('Now in:'.ljust(pad1), r)

            # 2. Delete any rulesets marked for deletion
            print("delete ruleset?",  form[r].delete_ruleset.data)
            if form[r].delete_ruleset.data:
                print('deleting:'.ljust(pad1), rulesets[r].name)
                del rulesets[r]
                active_rset = None
                print('rulesets now:'.ljust(pad1), [n for n in rulesets])
                break

            # 3. Of remaining rulesets, update data according to form fields (NB including r_func field)
            #   - set the function (lookup from func_table to get the right expression)
            print("setting r/func to:".ljust(pad1), func_table.get(form[r]['rfunc'].data, None))
            rulesets[r].func = func_table.get(form[r]['rfunc'].data, None)
            print('params from form1:'.ljust(pad1), form[r]['params'].data)
            print('function in ruleset:'.ljust(pad1), rulesets[r].func)
            
            #   - copy parameters from form to f_args dict (actually param:arg pairs) in ruleset
            #       first need to variablise - do this first in the form, before updating the ruleset
            #       note that the form will reset to a string, as these are StringFields
            for p in form[r]['params'].data:
                print("..in parameter".ljust(pad1), p)
                print("..current contents:".ljust(pad1), form[r]['params'][p].data)
                form[r]['params'][p].data = variablise(form[r]['params'][p].data)

            #    - now write to variablised param:args to the ruleset
            rulesets[r].f_args = form[r]['params'].data
            del rulesets[r].f_args['csrf_token']

            print("f_args in ruleset:".ljust(pad1), rulesets[r].f_args)

            #     - now set the index slice strings.  

            rulesets[r].string_slice = form[r]['string_slice'].data
            del rulesets[r].string_slice['csrf_token']
            rulesets[r].slicify_string()

            # calculate and plot if reqd
            print("checking if PLOT")
            if form[r].plot_ruleset.data:
                # try:  # NEED A FUNCTION FOR THIS (plotting, at least)
                rulesets[r].xtrap(npers)
                print('xtrap returned')
                fig = (rulesets[r].summed*phx_adj*12/1000000).plot(kind='Area', stacked='True', legend=True, figsize=(7,4), alpha=0.5).get_figure()
                ts = int((datetime.now() - datetime(1970,1,1)).total_seconds())
                outfig = str('static/'+ r + "_" + str(ts) + '.png')
                fig.savefig(outfig)
                print("SAVING FIG AS:".ljust(pad1), outfig)
                outfigs[r] = outfig
                print("Outfigs dict:".ljust(pad1), outfigs)
                # except: 
                #     print("could not save", rulesets[r].name)
                
                form[r].plot_ruleset.data = False 
                active_rset = rulesets[r].name



            # save if required
            print("checking if SAVE")
            if form[r].save_ruleset.data:
                with open('rulesets/'+str(r)+'.pkl', 'wb') as f:
                    pickle.dump(rulesets[r], f, protocol=pickle.HIGHEST_PROTOCOL)
                form[r].save_ruleset.data == False
                active_rset = rulesets[r].name

            # dump to xls if required
            print("checking if DUMPING to excel")
            if form[r].dump_rset_to_xls.data:
                writer = pd.ExcelWriter('output/' + rulesets[r].name + '.xlsx')
                rulesets[r].past.to_excel(writer, 'past')
                rulesets[r].fut.to_excel(writer, 'fut')
                rulesets[r].joined.to_excel(writer, 'joined')
                rulesets[r].summed.to_excel(writer, 'summed')
                writer.save()
                form[r].dump_rset_to_xls.data == False
                active_rset = rulesets[r].name


        # 4. Create or load any new rulesets

        print("\nCHECKING FOR NEW RULESETS")     
        if form.add_ruleset.data and form.new_name.data:
            print('adding new ruleset:'.ljust(pad1), form.new_name.data)
            print('number before:'.ljust(pad1), len(rulesets))
            rulesets[form.new_name.data] = RuleSet.RuleSet(df,form.new_name.data)
            print('number after:'.ljust(pad1), len(rulesets))
            active_rset = form.new_name.data


        print("\nCHECKING FOR RULESETS TO LOAD")     
        # loads them, but fields get blanked when form is remade -so need to add after
        print(form.load_ruleset.data, form.load_name.data)
        if form.load_ruleset.data and form.load_name.data:
            print('loading ruleset:'.ljust(pad1), form.load_name.data)
            print('number before:'.ljust(pad1), len(rulesets))
            print('rulesets/'+str(form.load_name.data))
            print('loading as ', form.load_name.data.split('.')[0])
            try:
                with open('rulesets/'+str(form.load_name.data), 'rb') as f:
                    rulesets[form.load_name.data.split('.')[0]] = pickle.load(f)
                    active_rset = form.load_name.data.split('.')[0]

            except:
                print('could not open ', form.load_name.data)
            print('number after:'.ljust(pad1), len(rulesets))



        print('\nFINAL RULESETS')
        pprint.pprint(rulesets)


    print('\nFORM BEFORE PLOT')
    pprint.pprint(form.data)
    print('\nplot all flag:'.ljust(pad1), form.plot_all.data)

    if form.plot_all.data==True: 
        ('form.plot_all.data is TRUE')
        # form.plot_all.data=False
        out_dfs = []
        for r in rulesets:
            print("\nPLOTTING:".ljust(pad1), rulesets[r].name)
            out_dfs.append(rulesets[r].summed*phx_adj*12/1000000000)
            print('length of out_dfs:'.ljust(pad1), len(out_dfs))

        try:
            print('out_df list is: '.ljust(pad1), out_dfs)
            df_concat = pd.concat(out_dfs, axis=1)
            print('concatted, with shape '.ljust(pad1), len(df_concat))
            df_concat.to_csv('output/dfconcat.csv')
            fig = df_concat.plot(kind='Area', stacked='True', legend=True, 
                figsize=(14,8), alpha=0.5).get_figure()
            
            ts = int((datetime.now() - datetime(1970,1,1)).total_seconds())
            outfig = str('static/total_' + str(ts) + "_" + '.png')
            fig.savefig(outfig)
            outfigs['total'] = outfig
            active_rset = 'total'
            print("saving TOTAL fig as:".ljust(pad1), outfig)       

        except:
            print("couldn't make a total plot / figure")

        print('RULESET AFTER PLOTTING')
        pprint.pprint(rulesets)


    # 5. Call `make_form()` again, to make a new form based on the new ruleset dict structure
    # NB this will turn variables back to strings
    # turn off flags etc?
    print("\nRE-MAKING FORM FROM RULESETS")
    form = None
    form = make_form1(rulesets)

    # 6. Update form data
    if form.load_ruleset.data and form.load_name.data:
        print("trying to write form")
        f = form.load_name.data.split('.')[0]
        print(f)
        print(form.data[f])
        print(rulesets[f])
        form[f]['rname'].data = rulesets[f].name

        for i in rulesets[f].string_slice:
            print("..in parameter".ljust(pad1), i)
            print("..current contents:".ljust(pad1), form[f]['string_slice'][i].data)
            form[f]['string_slice'][i].data = rulesets[f].string_slice[i]

        for p in rulesets[f].f_args:
            print("..in parameter".ljust(pad1), p)
            print("..current contents:".ljust(pad1), form[f]['params'][p].data)
            form[f]['params'][p].data = rulesets[f].f_args[p]
        print('looking up ruleset func in func_table', 
            [k for k in func_table if func_table[k]==rulesets[f].func][0])
        form[f]['rfunc'].data = [k for k in func_table if func_table[k]==rulesets[f].func][0]
        form.load_ruleset.data = False
        form.load_name.data = ""

    
    pprint.pprint(form.data)


    form['add_ruleset'].data = False
    form['new_name'].data = ""
    for r in rulesets: # why do I need to do this?
        form[r]['rname'].data = r
    
    print("Outfigs dict:".ljust(pad1), outfigs)

    session['last_active_rset'] = active_rset

    return render_template('main_template1.html', form=form, active_rset=active_rset,
                                rulesets=[n for n in rulesets], outfigs=outfigs)

@app.route('/test/')
def test():
    return render_template('tests.html')

if __name__ == '__main__':
    app.run()

